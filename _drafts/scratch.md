---
layout: post
title: What DDD isn't - part 1 - ditch the database
---
Well it's certainly not creating a couple of HashMaps in your code that contain properties that vaguely resemble something that one of your business sponsors mentioned in passing, and calling it DDD. No. It's not that although I suppose that's a start.

It's not even creating a couple of classes that represent business concepts and putting a `public long getId();` method on them that returns a database generated sequence number. I mean that's a start, it really is, but people have been doing that for years - at best it's a relational model of the business domain.

For a start, get rid of the database generated ids - they're really very unlikely to part of the domain and DDD is all about the ubiquitous domain isn't it? Don't get me wrong, DDD defines entities as having identity but that shouldn't be understood as identity generated by your RDBMS software.

Imagine a conversation with a domain expert about a domain concept, let's say the guy behind the counter in the local kebab shop. (You've decided there's just not enough IT in kebabs these days and so you're going to write him some software to help him out). You ask him, "if someone walks in and asks for 3 chicken shish, one chilli sauce, two garlic, how do you keep track of which is which?" Which of these does he say?

1. "I phone up my friend with the computer and ask him to spark up Oracle, generate me the next number in kebab_sequence and then I write it on the wrapper."
1. "I take a pseudo-random source of data, normally the temperature at the middle of my donner skewer and use it to seed a random number generator from which I can generate a UUID, of course I write this on the wrapper, it takes a while to write it my friend."
1. "C for chilli, G for garlic"

You've guessed it, at the point of kebab creation he does not, I repeat, *does not* generate a unique identifier for the finely crafted and indeed utterly unique kebab. In some ways the two garlic-sauced kebabs are indistinguishable and could even get confused, heaven forbid!

Now as a software developer with years of experience it's very easy to smile sweetly at kebab man and go off and generate that primary key anyway. You're *sure* that all systems need ids right? That's how you've always done it. How else would you uniquely identify that kebab when you want to give it to the customer, or work out how much it costs?

Well... no. This is an issue of dependency management, temporal coupling and of context.

Dependency management because in order to generate the id you normally have to persist the data to the database - *it does not have identity until it has been persisted*. That means you can't do anything with it that might use the id until it has been persisted. You can't give it a customer, you can't work out its cost, nothing. You do have a database right? You are ready to persist it? You can afford the I/O cost of persistence right now? The database software is an Infrastructure concern, you may not be planning to migrate to M$SqlServer tomorrow but please just trust me, you still don't want to have any dependencies between your domain and your infrastructure.

Temporal coupling because in most cases you would have to implement this by beginning a resource and lock-hungry database transaction now and keep it running until you've finished doing things with the kebab, even if those things might be slow... like eating it. You could persist it, commit, and then do things with it (at significant I/O cost), but what if the chef drops it on the floor as he's passing it to you and have to invoke `replaceKebabForFree()`? What about the kebab identifier you've used up - does it exist or not? Did you pay for the dropped kebab or the replacement kebab? You've got ids in the database that represent kebabs that don't exist! Stop it, you're making Bruce Willis jealous.

And context most importantly of all because in all the scenarios we've discussed there is absolutely no reason to uniquely distinguish your kebabs from all the other kebabs that have ever been served up (they all taste the same after a few beers anyway right?) Charging for it involves knowing what's in it, not it's identity, giving it to the customer is lossy, it's ok if he gets the 2 garlic-sauced ones mixed up, (it really is, have tried it). I suppose if you really tried hard you could perhaps imagine up a context where unique identity would be useful - a kebab archivist, travelling the world collecting data on every kebab ever produced in order to publish his great work "kebabs of the world".

Are you building software for the kebab archivist? I think I'd probably ask him to generate his own ids to be honest.

*Disclaimer: I struggle with titles for my blogs, for that matter with the content too. I am in no way trying to define Domain Driven Design - that responsibility lies happily with Eric Evans - but I see a huge potential for teams to develop better software by applying DDD, and sadly see so many cases where teams pay lip-service to it without unlocking that potential. This article and hopefully others to follow are intending to assist with the shift in how development teams should think about development when applying DDD. If any of the many that are far wiser than me believe I am not representing DDD correctly then let me know and I'll gladly adapt accordingly.*
